import{_ as s,c as a,o as e,ae as n}from"./chunks/framework.BHrE6nLq.js";const c=JSON.parse('{"title":"Performance en JavaScript","description":"","frontmatter":{},"headers":[],"relativePath":"performance.md","filePath":"performance.md"}'),l={name:"performance.md"};function t(r,i,h,p,k,o){return e(),a("div",null,i[0]||(i[0]=[n(`<h1 id="performance-en-javascript" tabindex="-1">Performance en JavaScript <a class="header-anchor" href="#performance-en-javascript" aria-label="Permalink to &quot;Performance en JavaScript&quot;">​</a></h1><h2 id="comparacion-de-redimiento" tabindex="-1">Comparacion de redimiento <a class="header-anchor" href="#comparacion-de-redimiento" aria-label="Permalink to &quot;Comparacion de redimiento&quot;">​</a></h2><p>Para comparar el rendimiento de los métodos forEach, map, reduce y un bucle for tradicional en JavaScript, ejecutaremos pruebas de tiempo sobre un array grande y analizaremos cuál es más eficiente en términos de tiempo de ejecución.</p><p>ç</p><ul><li><strong>Bucle for tradicional</strong>: <ul><li>Se considera la opción más rápida porque no introduce funciones de callback adicionales.</li><li>Evita la sobrecarga de métodos de alto nivel.</li><li>Permite mayor control sobre la iteración.</li></ul></li><li><strong>forEach</strong>: <ul><li>Ejecuta una función de callback sobre cada elemento.</li><li>No devuelve un nuevo array, pero sigue teniendo la sobrecarga del callback.</li></ul></li><li><strong>map</strong>: <ul><li>Similar a forEach, pero devuelve un nuevo array.</li><li>Tiene la sobrecarga del callback + la asignación de memoria para el nuevo array.</li></ul></li><li><strong>reduce</strong>: <ul><li>Recorre el array y acumula un resultado.</li><li>Puede ser más lento que forEach y map en ciertos casos, debido a la función de reducción.</li></ul></li></ul><h3 id="codigo-de-comparacion-de-rendimiento" tabindex="-1">Código de comparación de rendimiento <a class="header-anchor" href="#codigo-de-comparacion-de-rendimiento" aria-label="Permalink to &quot;Código de comparación de rendimiento&quot;">​</a></h3><p>Vamos a ejecutar cada método sobre un array de 10,000,000 de elementos y medir el tiempo.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arraySize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10_000_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> numbers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ length: arraySize }, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Medir tiempo del bucle for</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;for&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sumFor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sumFor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers[i];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">timeEnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;for&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Medir tiempo de forEach</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;forEach&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sumForEach </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">numbers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">num</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sumForEach </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">timeEnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;forEach&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Medir tiempo de map</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;map&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mappedArray</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">num</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">timeEnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;map&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Medir tiempo de reduce</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;reduce&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sumReduce</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reduce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">acc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> acc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">timeEnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;reduce&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="resultados-esperados" tabindex="-1">Resultados esperados <a class="header-anchor" href="#resultados-esperados" aria-label="Permalink to &quot;Resultados esperados&quot;">​</a></h3><p>Aunque los tiempos pueden variar según el entorno, generalmente ocurre lo siguiente:</p><ol><li>Bucle <strong>for</strong> suele ser el más rápido, ya que no tiene la sobrecarga de funciones de alto nivel ni la necesidad de crear nuevos arrays.</li><li><strong>forEach</strong> es más lento que for porque introduce una función de callback en cada iteración.</li><li><strong>map</strong> es aún más lento porque crea un nuevo array, lo que implica más uso de memoria.</li><li><strong>reduce</strong> puede ser similar a forEach, pero en algunos casos más lento debido a la acumulación de valores.</li></ol><h3 id="escalabilidad-y-complejidad" tabindex="-1">Escalabilidad y complejidad <a class="header-anchor" href="#escalabilidad-y-complejidad" aria-label="Permalink to &quot;Escalabilidad y complejidad&quot;">​</a></h3><p>Todos estos métodos tienen complejidad O(n), ya que recorren el array una vez.</p><p>Sin embargo, en términos de constante de tiempo, el bucle for tiene la menor sobrecarga, seguido de forEach, luego reduce, y por último map (porque asigna memoria para un nuevo array).</p><p>En términos de notación Big-O (O-notation), todos los métodos (for, forEach, map, reduce) tienen una complejidad de O(n), ya que cada uno recorre el array una vez, procesando cada elemento una sola vez.Sin embargo, la diferencia radica en la constante de tiempo y la sobrecarga de operaciones adicionales:</p><h3 id="comparacion-de-eficiencia-en-o-n" tabindex="-1">Comparación de eficiencia en O(n) <a class="header-anchor" href="#comparacion-de-eficiencia-en-o-n" aria-label="Permalink to &quot;Comparación de eficiencia en O(n)&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Método</th><th>Complejidad</th><th>Eficiencia relativa</th></tr></thead><tbody><tr><td><code>for</code></td><td>O(n)</td><td><strong>Más eficiente</strong> (menor overhead)</td></tr><tr><td><code>forEach</code></td><td>O(n)</td><td>Menos eficiente que <code>for</code> (callback overhead)</td></tr><tr><td><code>map</code></td><td>O(n)</td><td>Peor que <code>forEach</code> (crea un nuevo array)</td></tr><tr><td><code>reduce</code></td><td>O(n)</td><td>Similar a <code>forEach</code>, pero con acumulación</td></tr></tbody></table><h3 id="justificacion" tabindex="-1">Justificación <a class="header-anchor" href="#justificacion" aria-label="Permalink to &quot;Justificación&quot;">​</a></h3><ul><li>Bucle <strong>for</strong> es el más eficiente porque evita la sobrecarga de funciones de alto nivel y llamadas a callbacks en cada iteración.</li><li><strong>forEach</strong> es menos eficiente porque llama a una función de callback en cada iteración.</li><li><strong>map</strong> es aún menos eficiente porque, además de recorrer el array, crea un nuevo array (mayor uso de memoria).</li><li><strong>reduce</strong> también tiene la sobrecarga del callback y la acumulación de valores, lo que lo hace menos eficiente en comparación con for.</li></ul>`,19)]))}const E=s(l,[["render",t]]);export{c as __pageData,E as default};
